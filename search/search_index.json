{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Schedule","text":"<p>Schedule is the automatic scheduler for astronomical observations for the Gemini Program Platform.</p> <ul> <li>Go to Getting started on instruction on how to install and run the scheduler.</li> <li>You can use the playground or a script to run the Scheduler. To learn go to First steps.</li> </ul>"},{"location":"#license","title":"License","text":"<p>Copyright (c) 2016-2025 Association of Universities for Research in Astronomy, Inc. (AURA) For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause</p>"},{"location":"architecture/","title":"High-Level Architecture","text":"<p>Below shows a High-Level architecture for the Scheduler process. This exact proces is done in both the GraphQL server</p> <pre><code>flowchart LR\n  SP[Scheduler Parameters]\n  subgraph Engine[\"Engine\"]\n    direction LR\n    Builder[Builder]\n    subgraph CorePipeline[\"Scheduler Core Pipeline\"]\n      direction TB\n      Collector[Collector]\n      Selector[Selector]\n      Optimizer[Optimizer]\n    end\n    EventQueue[EventQueue]\n    EventCycle[EventCycle]\n  end\n  Timelines[Timelines]\n  RunSummary[Run Summary]\n\n  SP -- new() --&gt; Builder\n  Builder --&gt; CorePipeline\n  CorePipeline --&gt; EventCycle\n  EventQueue --&gt; EventCycle\n  EventCycle -- run() --&gt; Timelines\n  EventCycle -- run() --&gt; RunSummary\n</code></pre>"},{"location":"architecture/#scheduler-parameters","title":"Scheduler Parameters","text":""},{"location":"architecture/#scheduler.engine.SchedulerParameters","title":"<code>scheduler.engine.SchedulerParameters(start, end, sites, mode, ranker_parameters=RankerParameters(), semester_visibility=True, num_nights_to_schedule=None, programs_list=None)</code>","text":"<p>Initial parameters to start the scheduler engine. The start parameter represents both the initial local night that is going to be schedule and the initial date for the visibility calculation.</p> ATTRIBUTE DESCRIPTION <code>start</code> <p>start UT date.</p> <p> TYPE: <code>Time</code> </p> <code>end</code> <p>end UT date. Represents the end of the calculated visibility period.</p> <p> TYPE: <code>Time</code> </p> <code>mode</code> <p>The mode the Scheduler can be executed in. VALIDATION, SIMULATION or OPERATION.</p> <p> TYPE: <code>SchedulerModes</code> </p> <code>ranker_parameters</code> <p>Parameters that can be toggled in the Ranker to modify score.</p> <p> TYPE: <code>RankerParameters</code> </p> <code>semester_visibility</code> <p>Overrides the end parameters and extends the visibility period to the end of the selected semester in start.</p> <p> TYPE: <code>bool</code> </p> <code>num_nights_to_schedule</code> <p>Number of nights to schedule. Can't be bigger then the amount of nights in the visibility period. Defaults to None.</p> <p> TYPE: <code>int</code> </p> <code>programs_list</code> <p>A list of ProgramID that allows a specific selection of programs to run. Defaults to None. If None, the default programs list in scheduler/data would be used.</p> <p> TYPE: <code>List[str]</code> </p> <p>Examples:</p> <pre><code>   from scheduler.engine import SchedulerParameters, Engine\n   params = SchedulerParameters(start=Time(\"2018-10-01 08:00:00\", format='iso', scale='utc'),\n                                 end=Time(\"2018-10-03 08:00:00\", format='iso', scale='utc'),\n                                 sites=ALL_SITES,\n                                 mode=SchedulerModes.VALIDATION,\n                                 ranker_parameters=RankerParameters(),\n                                 semester_visibility=False,\n                                 num_nights_to_schedule=1,\n                                 programs_list=programs_list)\n</code></pre>"},{"location":"architecture/#engine","title":"Engine","text":""},{"location":"architecture/#scheduler.engine.Engine","title":"<code>scheduler.engine.Engine(params, night_start_time=None, night_end_time=None)</code>","text":""},{"location":"architecture/#scheduler.engine.Engine.build","title":"<code>build()</code>","text":"<p>Creates a Scheduler Core Pipeline based on the parameters. Also initialize both the Event Queue , both needed for the scheduling process.</p>"},{"location":"first-steps/","title":"First Steps","text":"<p>There are two ways to run the Scheduler the <code>run.py</code> script and the GraphQL playground.</p>"},{"location":"first-steps/#runpy-script","title":"run.py Script","text":"<p>To run the script do: <pre><code>$ python scheduler/scripts/run.py\n</code></pre> That would run the default parameters inside the script to modify those you need to modify the SchedulerParameters.</p>"},{"location":"first-steps/#graphql-playground","title":"GraphQL Playground","text":"<p>To run the server do: <pre><code>$ python scheduler/main.py\n</code></pre></p> <p>To access the Graphql playground you can go to <code>http://localhost:8000/graphql</code>. </p> <p>The Scheduler request work on two steps: the first one is a query sending the Scheduler Parameters and the request for a new plan and the second one is subscription that outputs the results. Both of these need to be in separate tabs in the browser to work properly.</p>"},{"location":"first-steps/#query-example","title":"Query Example","text":"<pre><code>query Schedule {\n                schedule(scheduleId: \"1\", \n                         newScheduleInput: {startTime: \"2018-10-01 08:00:00\",\n                                            endTime: \"2018-10-04 08:00:00\"\n                                            sites: \"GN\", \n                                            mode: SIMULATION,\n                                            semesterVisibility:false,\n                                            numNightsToSchedule:1})\n            }\n</code></pre>"},{"location":"first-steps/#subscription-example","title":"Subscription Example","text":"<p>Check the ID is the same as the query, so the response is matched with the request. <pre><code>subscription QueueSchedule {\n  queueSchedule(scheduleId: \"1\") {\n    __typename\n    ... on NewNightPlans {\n      nightPlans {\n        nightTimeline {\n          nightIndex\n          timeEntriesBySite {\n            site\n            timeLosses\n            timeEntries {\n              event\n              plan {\n                startTime\n                endTime\n                nightConditions {\n                  iq\n                  cc\n                }\n                visits {\n                  obsId\n                }\n                nightStats {\n                  planScore\n                  timeLoss\n                }\n              }\n            }\n          }\n        }\n      }\n      plansSummary{\n        metricsPerBand\n        summary\n      }\n    }\n    ... on NightPlansError {\n      error\n    }\n  }\n}\n</code></pre></p>"},{"location":"getting-started/","title":"1. Prerequisites","text":"<p>The Scheduler supports both 3.10 and 3.11 Python version. Newer versions are not tested yet. For the list of dependencies check: requirements.txt.</p> <p>Redis is currently used in the default configuration but can be deactivated.</p>"},{"location":"getting-started/#12-ephemerides-files-storage-for-validation","title":"1.2 Ephemerides files storage for Validation","text":"<p>The system connects to NASA's Horizons to handle Non-Sidereal Targets but  due to the amount of data we store all the ephemerides files for 2018B Semester that are needed to create the whole semester.  Is possible to skip this step but the performance of the Scheduler would be severely hindered. The files are in a .bz2 compressed file in <code>/scheduler/scheduler/services/horizons/data/</code> and it needs <code>git-lfs</code> to be cloned from the repo.  You can install it from here</p>"},{"location":"getting-started/#2-installation","title":"2. Installation","text":""},{"location":"getting-started/#21-local-development","title":"2.1 Local Development","text":"<p>Download the project source:</p> <pre><code>$ git clone https://github.com/gemini-hlsw/scheduler.git\n</code></pre>"},{"location":"getting-started/#211-create-the-project-environment-using-uv","title":"2.1.1 Create the project environment using uv:","text":"<p>Make sure you have an active 3.11 distribution installed on your machine.</p> <p>uv can be installed using curl: <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre></p> <p>Then in the project directory, execute:</p> <pre><code>$ uv sync\n</code></pre>"},{"location":"getting-started/#212-unzip-ephemerides-file-storage","title":"2.1.2 Unzip ephemerides file storage","text":"<pre><code>$ tar -xjf /scheduler/scheduler/services/horizons/data/ephemerides.tar.bz2\n</code></pre>"},{"location":"getting-started/#22-docker","title":"2.2 Docker","text":""},{"location":"getting-started/#221-run-docker-compose","title":"2.2.1. Run Docker-compose","text":"<p>If is the first time running the script, it will take some time to build the images. <pre><code>$ docker build -t scheduler .  \n$ docker run -dp 8000:8000 scheduler\n</code></pre></p> <p>Docker doesn't need to unzip the ephemerides storage file as that process is done in the Dockerfile</p>"},{"location":"getting-started/#4-configuration","title":"4. Configuration","text":"<p>The scheduler service needs the following environment variables:</p> <p>The redis url env name can't change because is how Heroku links the service on the cloud. <pre><code># URL to the Redis instance\nexport REDISCLOUD_URL=https::/url/for/redis\n# The version of the instance of the scheduler. In local development this value can be anything.\nexport API_VERSION=1.0\n</code></pre></p>"},{"location":"getting-started/#5-access-the-graphql-playground","title":"5. Access the GraphQL Playground","text":"<p>You can access <code>http://localhost:8000/graphql</code> to interact with the GraphQL console.</p> <p>On how to interact with the Playground go to First Steps page to see some examples.</p>"},{"location":"core-components/events/","title":"Events","text":"<p>The scheduler reacts to different events throughout the night allowing him to emulate the behavior that could happen if the telescope is shutdown or a rapid ToO is activated.</p> <p>The following are the types of events that are currently handle by the scheduler:</p>"},{"location":"core-components/events/#base-event","title":"Base event","text":""},{"location":"core-components/events/#scheduler.core.events.queue.Event","title":"<code>scheduler.core.events.queue.Event(site, time, description)</code>","text":"<p>               Bases: <code>UUIDIdentified</code>, <code>ABC</code></p> <p>Superclass for all events. They contain:</p> ATTRIBUTE DESCRIPTION <code>site</code> <p>The site at which the event occurred.</p> <p> TYPE: <code>Site</code> </p> <code>time</code> <p>The time at which the event occurred.</p> <p> TYPE: <code>datetime</code> </p> <code>description</code> <p>A human-readable description of the event.</p> <p> TYPE: <code>str</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.Event.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#abstract-events","title":"Abstract events","text":"<p>These events are general purpose events that describe a non-specific behavior in the night.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.RoutineEvent","title":"<code>scheduler.core.events.queue.RoutineEvent(site, time, description)</code>","text":"<p>               Bases: <code>Event</code>, <code>ABC</code></p> <p>A routine event that is predictable and processed by the Scheduler. Examples include evening and morning twilight.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.RoutineEvent.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.InterruptionEvent","title":"<code>scheduler.core.events.queue.InterruptionEvent(site, time, description)</code>","text":"<p>               Bases: <code>Event</code>, <code>ABC</code></p> <p>Parent class for any interruption that might cause a new schedule to be created. These events include:</p> <ol> <li>Events that have no specified end time (e.g. weather changes).</li> <li>Events that have a specified end time (e.g. engineering tasks, faults) and thus are paired together    with an InterruptionResolutionEvent.</li> </ol>"},{"location":"core-components/events/#scheduler.core.events.queue.InterruptionEvent.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#twilight-events","title":"Twilight events","text":"<p>They marked the start and end of the night. Without them the event cycle won't start and  the final plan can't be created.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.TwilightEvent","title":"<code>scheduler.core.events.queue.TwilightEvent(site, time, description)</code>","text":"<p>               Bases: <code>RoutineEvent</code>, <code>ABC</code></p> <p>An event indicating that the 12 degree starting twilight for a night has been reached.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.TwilightEvent.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.EveningTwilightEvent","title":"<code>scheduler.core.events.queue.EveningTwilightEvent(site, time, description)</code>","text":"<p>               Bases: <code>TwilightEvent</code></p> <p>An event indicating that the 12 degree starting twilight for a night has been reached.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.EveningTwilightEvent.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.MorningTwilightEvent","title":"<code>scheduler.core.events.queue.MorningTwilightEvent(site, time, description)</code>","text":"<p>               Bases: <code>TwilightEvent</code></p> <p>An event indicating that the 12 degree morning twilight     for a night has been reached. This is used to finalize the time accounting for the night.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.MorningTwilightEvent.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#interruption-and-resolution-events","title":"Interruption and Resolution events","text":"<p>Are all the events that might interrupt the current plan and might trigger a different plan with different conditions. Some interruptions create a lasting effect that might be resolved later in the night.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.WeatherChangeEvent","title":"<code>scheduler.core.events.queue.WeatherChangeEvent(site, time, description, variant_change)</code>","text":"<p>               Bases: <code>InterruptionEvent</code></p> <p>Interruption that occurs when new a new weather variant comes in.</p> ATTRIBUTE DESCRIPTION <code>variant_change</code> <p>The variant snapshot that changed.</p> <p> TYPE: <code>VariantSnapshot</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.WeatherChangeEvent.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.ToOActivationEvent","title":"<code>scheduler.core.events.queue.ToOActivationEvent(site, time, description, too_id)</code>","text":"<p>               Bases: <code>InterruptionEvent</code></p> <p>Change the status of a ToO from ON_HOLD to READY.</p> ATTRIBUTE DESCRIPTION <code>too_id</code> <p>The observation ID for the ToO that was activated.</p> <p> TYPE: <code>ObservationID</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.ToOActivationEvent.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.FaultEvent","title":"<code>scheduler.core.events.queue.FaultEvent(site, time, description, affects)</code>","text":"<p>               Bases: <code>InterruptionEvent</code></p> <p>Interruption that occurs when there is a fault in a resource. In OCS, this will likely be the site itself where the fault occurred.</p> ATTRIBUTE DESCRIPTION <code>affects</code> <p>Resource affected for the fault.</p> <p> TYPE: <code>FrozenSet[Resource]</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.FaultEvent.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.WeatherClosureEvent","title":"<code>scheduler.core.events.queue.WeatherClosureEvent(site, time, description)</code>","text":"<p>               Bases: <code>InterruptionEvent</code></p> <p>A weather closure for a given site. This will be treated like a FaultEvent, but the \"affects\" Resource will be the entire site.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.WeatherClosureEvent.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.InterruptionResolutionEvent","title":"<code>scheduler.core.events.queue.InterruptionResolutionEvent(uuid_identified, site, time, description)</code>","text":"<p>               Bases: <code>Event</code>, <code>UUIDReferenced</code>, <code>ABC</code></p> <p>A class representing the resolution of an interruption that     can be resolved (e.g. a resolved fault or the end of an engineering task.)</p> <p>These events, signifying the end of a period of time, can be used to generate a time loss.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.InterruptionResolutionEvent.time_loss","title":"<code>time_loss</code>","text":"<p>Calculate the time loss from this InterruptionEvent to this InterruptionEventResolution as a timedelta.</p> <p>TO DO</p> <p>TODO: This assumes that Interruption events are notified or processed at Twilight (or near) situation that might TODO: be completely different when Resource is implemented and real input is processed.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.InterruptionResolutionEvent.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.InterruptionResolutionEvent.time_slot_loss","title":"<code>time_slot_loss(time_slot_length)</code>","text":"<p>Given the length of a time slot, calculate the number of time slots lost from the InterruptionEvent to     this InterruptionEventResolution.</p> PARAMETER DESCRIPTION <code>time_slot_length</code> <p>The length of the time slot to calculate the number of time slots lost.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The number of time slots lost from the Interruption.</p> <p> TYPE: <code>int</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.FaultResolutionEvent","title":"<code>scheduler.core.events.queue.FaultResolutionEvent(uuid_identified, site, time, description)</code>","text":"<p>               Bases: <code>InterruptionResolutionEvent</code>, <code>UUIDReferenced</code></p> <p>Interruption that occurs when a Fault is resolved.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.FaultResolutionEvent.time_loss","title":"<code>time_loss</code>","text":"<p>Calculate the time loss from this InterruptionEvent to this InterruptionEventResolution as a timedelta.</p> <p>TO DO</p> <p>TODO: This assumes that Interruption events are notified or processed at Twilight (or near) situation that might TODO: be completely different when Resource is implemented and real input is processed.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.FaultResolutionEvent.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.FaultResolutionEvent.time_slot_loss","title":"<code>time_slot_loss(time_slot_length)</code>","text":"<p>Given the length of a time slot, calculate the number of time slots lost from the InterruptionEvent to     this InterruptionEventResolution.</p> PARAMETER DESCRIPTION <code>time_slot_length</code> <p>The length of the time slot to calculate the number of time slots lost.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The number of time slots lost from the Interruption.</p> <p> TYPE: <code>int</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.WeatherClosureResolutionEvent","title":"<code>scheduler.core.events.queue.WeatherClosureResolutionEvent(uuid_identified, site, time, description)</code>","text":"<p>               Bases: <code>InterruptionResolutionEvent</code>, <code>UUIDReferenced</code></p> <p>Interruption that occurs when a WeatherClosure is resolved.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.WeatherClosureResolutionEvent.time_loss","title":"<code>time_loss</code>","text":"<p>Calculate the time loss from this InterruptionEvent to this InterruptionEventResolution as a timedelta.</p> <p>TO DO</p> <p>TODO: This assumes that Interruption events are notified or processed at Twilight (or near) situation that might TODO: be completely different when Resource is implemented and real input is processed.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.WeatherClosureResolutionEvent.to_timeslot_idx","title":"<code>to_timeslot_idx(twi_eve_time, time_slot_length)</code>","text":"<p>Given an event, calculate the timeslot offset it falls into relative to another datetime. This would typically be the twilight of the night on which the event occurs, hence the name twi_eve_time.</p> PARAMETER DESCRIPTION <code>twi_eve_time</code> <p>Evening twilight time.</p> <p> TYPE: <code>datetime</code> </p> <code>time_slot_length</code> <p>Set time slot length in which the Scheduler work.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>TimeslotIndex</code> <p>The timeslot offset relative to the twilight.</p> <p> TYPE: <code>TimeslotIndex</code> </p>"},{"location":"core-components/events/#scheduler.core.events.queue.WeatherClosureResolutionEvent.time_slot_loss","title":"<code>time_slot_loss(time_slot_length)</code>","text":"<p>Given the length of a time slot, calculate the number of time slots lost from the InterruptionEvent to     this InterruptionEventResolution.</p> PARAMETER DESCRIPTION <code>time_slot_length</code> <p>The length of the time slot to calculate the number of time slots lost.</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The number of time slots lost from the Interruption.</p> <p> TYPE: <code>int</code> </p>"},{"location":"core-components/events/#event-queue","title":"Event Queue","text":"<p>The <code>Event Queue</code> allows the scheduler to keep all events ordered chronologically. This is separated in two: One that compromises all the nights and sites and one that is specific for a night.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.EventQueue","title":"<code>scheduler.core.events.queue.EventQueue(night_indices, sites)</code>","text":""},{"location":"core-components/events/#scheduler.core.events.queue.EventQueue.get_night_events","title":"<code>get_night_events(night_idx, site)</code>","text":"<p>Returns the sorted list for the site for the night index if it exists, else None.</p>"},{"location":"core-components/events/#scheduler.core.events.queue.NightEventQueue","title":"<code>scheduler.core.events.queue.NightEventQueue(night_idx, site)</code>","text":""},{"location":"core-components/events/#event-cycle","title":"Event Cycle","text":"<p>Encapsulates all the behavior the events can be affected through the night and pass the event to be process by the <code>Change Monitor</code> and controls when the time accounting and the plans creation happens.</p>"},{"location":"core-components/events/#scheduler.core.events.cycle.EventCycle","title":"<code>scheduler.core.events.cycle.EventCycle(params, queue, scp)</code>","text":"ATTRIBUTE DESCRIPTION <code>params</code> <p>Scheduler parameters</p> <p> TYPE: <code>SchedulerParams</code> </p> <code>queue</code> <p>Event queue that orders the events chronologically</p> <p> TYPE: <code>EventQueue</code> </p> <code>scp</code> <p>The Scheduler Core Pipeline that allows creating plans.</p> <p> TYPE: <code>SCP</code> </p>"},{"location":"core-components/events/#scheduler.core.events.cycle.EventCycle.run","title":"<code>run(site, night_idx, nightly_timeline)</code>","text":"<p>Executes the Event cycle for a specific site and night.</p> PARAMETER DESCRIPTION <code>site</code> <p>Site to process events from the night.</p> <p> TYPE: <code>Site</code> </p> <code>night_idx</code> <p>Night to process events from.</p> <p> TYPE: <code>NightIndex</code> </p> <code>nightly_timeline</code> <p>Records all the events and their corresponding plans.</p> <p> TYPE: <code>NightlyTimeline</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If required events are missing</p>"},{"location":"core-components/events/#change-monitor","title":"Change Monitor","text":"<p>Matches the event with their specific behavior. These are usually modifications to both <code>Collector</code> and <code>Selector</code>.</p> <p>The <code>Change Monitor</code> gives updates to the <code>Event Cycle</code> through Time Coordinate Record so the  cycle knows which updates are needed after that event.</p>"},{"location":"core-components/events/#scheduler.core.components.changemonitor.ChangeMonitor","title":"<code>scheduler.core.components.changemonitor.ChangeMonitor(collector, selector)</code>","text":"<p>               Bases: <code>SchedulerComponent</code></p> <p>Triggers different changes caused by events in the Scheduler components</p> ATTRIBUTE DESCRIPTION <code>collector</code> <p>Collector instance when observations need to be updated or changed their Status.</p> <p> TYPE: <code>Collector</code> </p> <code>selector</code> <p>Selector instance when weather conditions are modified.</p> <p> TYPE: <code>Selector</code> </p>"},{"location":"core-components/events/#scheduler.core.components.changemonitor.ChangeMonitor.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Create the blocking event set for each site.</p>"},{"location":"core-components/events/#scheduler.core.components.changemonitor.ChangeMonitor.is_site_unblocked","title":"<code>is_site_unblocked(site)</code>","text":"<p>Check if a site is unblocked.</p> PARAMETER DESCRIPTION <code>site</code> <p>Site to check.</p> <p> TYPE: <code>Site</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the given site is NOT blocked by one or more events that need to be resolved before the site can have a plan, and False if the site is blocked.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"core-components/events/#scheduler.core.components.changemonitor.ChangeMonitor.process_event","title":"<code>process_event(site, event, plans, night_idx)</code>","text":"<p>Given an event occurring at a given site and an optional plan running on the site, determine the next timeslot where the plan should be recalculated, if any.</p> <p>The plan is optional, because for EveningTwilightEvent, no plan has yet been computed and thus None should be passed in.</p> <p>If the ChangeMonitor determines that a new plan should be calculated, then a timeslot index indicating when the plan should be calculated is returned, and if no new plan should be calculated, then None is returned.</p> PARAMETER DESCRIPTION <code>site</code> <p>the site at which the event occurred</p> <p> TYPE: <code>Site</code> </p> <code>event</code> <p>the event that occurred</p> <p> TYPE: <code>Event</code> </p> <code>plans</code> <p>the plans that are currently in action (if any) for the night,  which consist of a plan per site</p> <p> TYPE: <code>Plans</code> </p> <code>night_idx</code> <p>the night index</p> <p> TYPE: <code>NightIdx</code> </p> <p>TO DO</p> <p>TODO: Might want to make return type a Tuple[NightIndex, TimeslotIndex].</p> RETURNS DESCRIPTION <code>TimeCoordinateRecord</code> <p>a time coordinate record which provides information about when the next plan should be computed  (if any), if a night is done, and if time accounting should be performed</p> <p> TYPE: <code>Optional[TimeCoordinateRecord]</code> </p>"},{"location":"core-components/events/#scheduler.core.components.changemonitor.TimeCoordinateRecord","title":"<code>scheduler.core.components.changemonitor.TimeCoordinateRecord(event, timeslot_idx, perform_time_accounting=True, done=False)</code>","text":"<p>Time coordinate record calculated for an event.</p> ATTRIBUTE DESCRIPTION <code>event</code> <p>the event for which this time coordinate record holds</p> <p> TYPE: <code>Event</code> </p> <code>timeslot_idx</code> <p>the timeslot index for which the plan should be recalculated</p> <p> TYPE: <code>Optional[TimeslotIndex]</code> </p> <code>perform_time_accounting</code> <p>True if time accounting should be performed, and False to suppress time accounting</p> <p> TYPE: <code>bool</code> </p> <code>done</code> <p>True if the night is done, and False otherwise</p> <p> TYPE: <code>bool</code> </p>"},{"location":"external-services/","title":"External Services","text":"<p>The Scheduler also provides several external service that emulates GPP services or functions so it can work with historical OCS data.</p> <p>These services are for Scheduler use only and allow the system to run in Validation Mode. They contain data from 2018A to 2019B.</p> <p>The following list shows all the currently implemented services:</p> <ul> <li>Resource: Emulates and interacts with GPP Resource</li> <li>Environment: Emulates and interacts with GPP Environment</li> <li>Ephemeris: Allows the scheduler to handle Non-Sidereal Targets using   the ephemerides files from Horizons.</li> <li>Horizons: Nasa Horizons client</li> <li>Proper Motion: Calculates the proper motion for Target coordinates</li> <li>Visibility: Allows the Scheduler to calculate the visibility values and fraction   for an specific Target.</li> </ul>"},{"location":"external-services/resource/","title":"Resource","text":"<p>The GPP Resource services allows other services in the GPP environment to  know what is available in the telescope at a giving night, from gratings to  the status of the status of an instrument. </p> <p>This service act like a client for the real Resource and the emulated version for OCS, that is based in several text files compiled from old OCS systems. The original files can be checked at <code>/scheduler/services/resource/src</code>and the ones actually used in the Scheduler are in the same path at <code>validation</code>.</p>"},{"location":"external-services/resource/#resource-structures","title":"Resource structures","text":""},{"location":"external-services/resource/#scheduler.services.resource.ResourceService","title":"<code>scheduler.services.resource.ResourceService(sites=ALL_SITES, subdir='')</code>","text":"<p>               Bases: <code>ExternalService</code></p> <p>This is to avoid recreating repetitive resources. When we first get a resource ID string, create a Resource for it and store it here. Then fetch the Resources from here if they exist, and if they do not, then create a new one as per the lookup_resource method.</p>"},{"location":"external-services/resource/#scheduler.services.resource.ResourceService.lookup_resource","title":"<code>lookup_resource(resource_id, description=None, resource_type=ResourceType.NONE)</code>","text":"<p>This is a helper method that just delegates to the ResourceManager cache. It is designed to minimize code changes and make the ResourceService use the cache transparently.</p>"},{"location":"external-services/resource/#scheduler.services.resource.ResourceService.date_range_for_site","title":"<code>date_range_for_site(site)</code>","text":"<p>Return the date range (inclusive) for which we have resource data for a site.</p>"},{"location":"external-services/resource/#scheduler.services.resource.ResourceService.get_night_configuration","title":"<code>get_night_configuration(site, local_date)</code>","text":"<p>Returns the NightConfiguration object for the site for the given local date, which contains the filters and resources for the night.</p>"},{"location":"external-services/resource/#scheduler.services.resource.ResourceService.fpu_to_barcode","title":"<code>fpu_to_barcode(site, fpu_name, instrument)</code>","text":"<p>Convert a long FPU name into the barcode, if it exists.</p>"},{"location":"external-services/resource/#scheduler.services.resource.FileBasedResourceService","title":"<code>scheduler.services.resource.FileBasedResourceService(sites=ALL_SITES, subdir='')</code>","text":"<p>               Bases: <code>ResourceService</code></p> <p>This is the base for both OCS and File-uploaded services</p>"},{"location":"external-services/resource/#scheduler.services.resource.FileBasedResourceService.lookup_resource","title":"<code>lookup_resource(resource_id, description=None, resource_type=ResourceType.NONE)</code>","text":"<p>This is a helper method that just delegates to the ResourceManager cache. It is designed to minimize code changes and make the ResourceService use the cache transparently.</p>"},{"location":"external-services/resource/#scheduler.services.resource.FileBasedResourceService.date_range_for_site","title":"<code>date_range_for_site(site)</code>","text":"<p>Return the date range (inclusive) for which we have resource data for a site.</p>"},{"location":"external-services/resource/#scheduler.services.resource.FileBasedResourceService.get_night_configuration","title":"<code>get_night_configuration(site, local_date)</code>","text":"<p>Returns the NightConfiguration object for the site for the given local date, which contains the filters and resources for the night.</p>"},{"location":"external-services/resource/#scheduler.services.resource.FileBasedResourceService.fpu_to_barcode","title":"<code>fpu_to_barcode(site, fpu_name, instrument)</code>","text":"<p>Convert a long FPU name into the barcode, if it exists.</p>"},{"location":"external-services/resource/#scheduler.services.resource.FileBasedResourceService.load_files","title":"<code>load_files(site, fpu_to_barcodes_file, fpus_data, gratings_data, faults_data, eng_tasks_data, weather_closure_data, filters_data, too_data, spreadsheet_file)</code>","text":"<p>Load all files necessaries to the correct functioning of the ResourceManager.</p>"},{"location":"external-services/resource/#scheduler.services.resource.OcsResourceService","title":"<code>scheduler.services.resource.OcsResourceService(sites=ALL_SITES, subdir='validation')</code>","text":"<p>               Bases: <code>FileBasedResourceService</code></p> <p>This is a mock for the future Resource service, used for OCS. It reads data regarding availability of instruments, IFUs, FPUs, MOS masks, etc. at each Site for given dates.</p> <p>It can then be queried to receive a set of Resource (usually with barcode IDs, except for instruments) for a given site on a given night.</p> <p>It caches and reuses Resources by ID as best as possible to minimize the number of Resource objects existing at any given time. Since Resource is immutable, this should be fine.</p> <p>Note that this is a Singleton class, so new instances do not need to be created.</p> <p>Create and initialize the OCS Resource object with the specified sites.</p>"},{"location":"external-services/resource/#scheduler.services.resource.OcsResourceService.lookup_resource","title":"<code>lookup_resource(resource_id, description=None, resource_type=ResourceType.NONE)</code>","text":"<p>This is a helper method that just delegates to the ResourceManager cache. It is designed to minimize code changes and make the ResourceService use the cache transparently.</p>"},{"location":"external-services/resource/#scheduler.services.resource.OcsResourceService.date_range_for_site","title":"<code>date_range_for_site(site)</code>","text":"<p>Return the date range (inclusive) for which we have resource data for a site.</p>"},{"location":"external-services/resource/#scheduler.services.resource.OcsResourceService.get_night_configuration","title":"<code>get_night_configuration(site, local_date)</code>","text":"<p>Returns the NightConfiguration object for the site for the given local date, which contains the filters and resources for the night.</p>"},{"location":"external-services/resource/#scheduler.services.resource.OcsResourceService.fpu_to_barcode","title":"<code>fpu_to_barcode(site, fpu_name, instrument)</code>","text":"<p>Convert a long FPU name into the barcode, if it exists.</p>"},{"location":"external-services/resource/#scheduler.services.resource.OcsResourceService.load_files","title":"<code>load_files(site, fpu_to_barcodes_file, fpus_data, gratings_data, faults_data, eng_tasks_data, weather_closure_data, filters_data, too_data, spreadsheet_file)</code>","text":"<p>Load all files necessaries to the correct functioning of the ResourceManager.</p>"},{"location":"external-services/resource/#scheduler.services.resource.resource_manager.ResourceManager","title":"<code>scheduler.services.resource.resource_manager.ResourceManager()</code>","text":"<p>A singleton class that manages Resource instances to reuse them as per the flyweight design pattern.</p> <p>Create an empty dictionary of mappings from name to Resource.</p>"},{"location":"external-services/resource/#scheduler.services.resource.resource_manager.ResourceManager.lookup_resource","title":"<code>lookup_resource(resource_id, description=None, resource_type=ResourceType.NONE)</code>","text":"<p>Function to perform Resource caching and minimize the number of Resource objects by attempting to reuse Resource objects with the same ID.</p> <p>If resource_id evaluates to False, return None. Otherwise, check if a Resource with id already exists. If it does, return it. If not, create it, add it to the map of all Resources, and then return it.</p> <p>Note that even if multiple objects do exist with the same ID, they will be considered equal by the Resource equality comparator.</p>"},{"location":"external-services/resource/#scheduler.services.resource.NightConfiguration","title":"<code>scheduler.services.resource.NightConfiguration(site, local_date, is_lgs, too_status, filter, resources, eng_tasks)</code>","text":""},{"location":"external-services/resource/#scheduler.services.resource.NightConfiguration.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Calculate values once to avoid recalculation.</p>"}]}